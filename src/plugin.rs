use std::path::Path;

use bevy::{
    app::{App, Plugin, PreStartup, Update},
    asset::{AssetServer, Handle},
    ecs::{
        component::Component,
        schedule::{
            common_conditions::{resource_changed, resource_exists, resource_removed},
            IntoSystemConfigs,
        },
        system::{Commands, Query, Res, ResMut},
    },
    text::{Font, TextFont},
    ui::widget::Text,
};

use crate::{
    components::{I18nFont, I18nNumber, I18nText},
    prelude::{I18nComponent, I18nText2d},
    resources::{FontFolder, FontManager, FontsLoading, I18n},
    FONT_FAMILIES,
};

/// Initializes the `bevy_simple_i18n` plugin
///
/// # Example
/// ```
/// use bevy::prelude::*;
/// use bevy_simple_i18n::prelude::*;
///
/// fn main() {
///     App::new()
///         .add_plugins(I18nPlugin)
///         .run();
/// }
/// ```
pub struct I18nPlugin;

impl Plugin for I18nPlugin {
    fn build(&self, app: &mut bevy::prelude::App) {
        app.init_resource::<I18n>()
            .init_resource::<FontManager>()
            .init_resource::<FontsLoading>()
            .add_systems(PreStartup, load_dynamic_fonts)
            .register_i18n_component::<I18nText>()
            .register_i18n_component::<I18nText2d>()
            .register_i18n_component::<I18nNumber>()
            .add_systems(
                Update,
                monitor_font_loading.run_if(resource_exists::<FontsLoading>),
            );
    }
}

pub trait I18nComponentRegistration {
    /// Registers an i18n component for automatic translation updates
    fn register_i18n_component<T: I18nComponent + Component>(&mut self) -> &mut Self;
}

impl I18nComponentRegistration for App {
    fn register_i18n_component<T: I18nComponent + Component>(&mut self) -> &mut Self {
        self.add_systems(
            Update,
            (
                update_text_translations::<T>.run_if(resource_removed::<FontsLoading>),
                update_text_translations::<T>.run_if(resource_changed::<I18n>),
            ),
        )
    }
}

/// Auto updates the translations for components that have the [I18nComponent] trait
/// and have been registered with the Bevy [App] using the [register_i18n_component] method
/// whenever the [I18n] resource changes
fn update_text_translations<T: I18nComponent + Component>(
    font_manager: bevy::ecs::system::Res<FontManager>,
    mut text_query: Query<(&mut Text, &mut TextFont, Option<&I18nFont>, &T)>,
) {
    bevy::log::debug!("Updating translations");
    for (mut text, mut text_font, dyn_font, key) in text_query.iter_mut() {
        text.0 = key.translate();
        if let Some(dyn_font) = dyn_font {
            text_font.font = font_manager.get(&dyn_font.0, key.locale());
        }
    }
}

/// Loads the dynamic fonts specified in the [FONT_FAMILIES] constant that's generated by the build script
///
/// TODO: Make the loading state more controllable
fn load_dynamic_fonts(
    mut font_manager: ResMut<FontManager>,
    asset_server: Res<bevy::asset::AssetServer>,
) {
    for dyn_font in FONT_FAMILIES.iter() {
        bevy::log::debug!("Loading dynamic font family: {}", dyn_font.family);
        let mut font_folder = FontFolder::default();
        font_folder.fallback = asset_server.load(Path::new(dyn_font.path).join("fallback.ttf"));
        for font in dyn_font.locales.iter() {
            bevy::log::debug!("Loading font: {}", font);
            let locale = font.split('.').next().expect("Locale is required");
            let path = Path::new(dyn_font.path).join(font);
            let handler: Handle<Font> = asset_server.load(path);
            font_folder.fonts.insert(locale.to_string(), handler);
        }
        font_manager.insert(dyn_font.family.to_string(), font_folder);
    }
}

/// Monitors the font loading state and removes the [FontsLoading] resource when all fonts are loaded
///
/// TODO: Make the loading state more controllable
fn monitor_font_loading(
    mut commands: Commands,
    font_manager: Res<FontManager>,
    asset_server: Res<AssetServer>,
) {
    for folder in font_manager.fonts.values() {
        for font in folder.fonts.values() {
            if !asset_server.is_loaded(font.id()) {
                return;
            }
        }
    }
    commands.remove_resource::<FontsLoading>();
    bevy::log::debug!("All fonts loaded");
}
